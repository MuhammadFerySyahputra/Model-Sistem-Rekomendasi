# -*- coding: utf-8 -*-
"""Membuat Model Sistem Rekomendasi.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19htPcWTDY2DM-HB1pXrj_Uji6F3-DWdL

## ===== 1. Import Library =====
"""

# Install library dengan versi yang kompatibel
!pip install numpy==1.23.5
!pip install pandas scikit-learn matplotlib seaborn surprise

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, mean_absolute_error
from surprise import Dataset, Reader, SVD, KNNBasic, accuracy
from surprise.model_selection import train_test_split as surprise_split
import warnings
warnings.filterwarnings('ignore')

"""## ===== 2. Download dan Persiapan Data =====

### Download dan extract dataset MovieLens
"""

# Download dataset
!wget https://files.grouplens.org/datasets/movielens/ml-latest-small.zip
!unzip -o ml-latest-small.zip

"""### Load data"""

print("\nLoading MovieLens dataset...")
movies_df = pd.read_csv('ml-latest-small/movies.csv')
ratings_df = pd.read_csv('ml-latest-small/ratings.csv')
tags_df = pd.read_csv('ml-latest-small/tags.csv')

# Rename columns untuk konsistensi
movies_df = movies_df.rename(columns={'movieId': 'movie_id'})
ratings_df = ratings_df.rename(columns={'movieId': 'movie_id', 'userId': 'user_id'})

# Extract year dari title
movies_df['year'] = movies_df['title'].str.extract(r'\((\d{4})\)').astype(float)
movies_df['title_clean'] = movies_df['title'].str.replace(r'\s*\(\d{4}\)', '', regex=True)

# Split genres menjadi list
movies_df['genre_list'] = movies_df['genres'].str.split('|')
movies_df['main_genre'] = movies_df['genre_list'].apply(lambda x: x[0] if x and x[0] != '(no genres listed)' else 'Unknown')

# Create content description untuk content-based filtering
movies_df['content'] = movies_df['genres'].fillna('') + ' ' + movies_df['title_clean'].fillna('')

"""### Lihat data"""

print("Dataset MovieLens berhasil dimuat!")
print(f"Jumlah film: {len(movies_df)}")
print(f"Jumlah rating: {len(ratings_df)}")
print(f"Jumlah user: {ratings_df['user_id'].nunique()}")
print(f"Rating range: {ratings_df['rating'].min()} - {ratings_df['rating'].max()}")

print("\n=== SAMPLE DATA ===")
print("Movies:")
print(movies_df[['movie_id', 'title', 'genres', 'year']].head())
print("\nRatings:")
print(ratings_df.head())

# Basic statistics
print("\n=== DATASET STATISTICS ===")
print("Rating Distribution:")
print(ratings_df['rating'].value_counts().sort_index())
print(f"\nMost rated movie: {movies_df.loc[movies_df['movie_id'] == ratings_df['movie_id'].mode()[0], 'title'].iloc[0]}")
print(f"Average rating: {ratings_df['rating'].mean():.2f}")

# Top genres
print("\nTop 10 Genres:")
all_genres = []
for genres in movies_df['genre_list']:
    if genres:
        all_genres.extend([g for g in genres if g != '(no genres listed)'])
genre_counts = pd.Series(all_genres).value_counts().head(10)
print(genre_counts)

"""## ===== 3. CONTENT-BASED FILTERING ====="""

class ContentBasedRecommender:
    def __init__(self, movies_df):
        self.movies_df = movies_df
        self.tfidf_matrix = None
        self.cosine_sim = None

    def build_content_features(self):
        """Membangun fitur konten dari film"""
        # TF-IDF Vectorization dari content yang sudah dibuat
        tfidf = TfidfVectorizer(stop_words='english', max_features=5000, ngram_range=(1, 2))
        self.tfidf_matrix = tfidf.fit_transform(self.movies_df['content'].fillna(''))

        # Cosine Similarity
        self.cosine_sim = cosine_similarity(self.tfidf_matrix)

        print("Content features berhasil dibangun!")
        print(f"TF-IDF Matrix shape: {self.tfidf_matrix.shape}")
        print(f"Feature vocabulary size: {len(tfidf.vocabulary_)}")

    def get_recommendations(self, movie_title, n_recommendations=5):
        """Mendapatkan rekomendasi berdasarkan film"""
        try:
            # Cari film berdasarkan title (case insensitive, partial match)
            matching_movies = self.movies_df[
                self.movies_df['title'].str.contains(movie_title, case=False, na=False) |
                self.movies_df['title_clean'].str.contains(movie_title, case=False, na=False)
            ]

            if matching_movies.empty:
                return f"Film '{movie_title}' tidak ditemukan dalam database"

            # Ambil film pertama jika ada beberapa match
            idx = matching_movies.index[0]
            selected_movie = matching_movies.iloc[0]

            print(f"Film yang dipilih: {selected_movie['title']} ({selected_movie['genres']})")

            # Hitung similarity scores
            sim_scores = list(enumerate(self.cosine_sim[idx]))
            sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)

            # Ambil top N recommendations (excluding the movie itself)
            movie_indices = [i[0] for i in sim_scores[1:n_recommendations+1]]

            recommendations = self.movies_df.iloc[movie_indices][['title', 'genres', 'year']].copy()
            recommendations['similarity_score'] = [sim_scores[i+1][1] for i in range(n_recommendations)]

            return recommendations

        except IndexError:
            return f"Terjadi error dalam mencari film '{movie_title}'"

# Implementasi Content-Based Filtering
print("\n=== CONTENT-BASED FILTERING ===")
cb_recommender = ContentBasedRecommender(movies_df)
cb_recommender.build_content_features()

# Test rekomendasi dengan film terkenal
sample_movies = ['Toy Story', 'Jurassic Park', 'Forrest Gump', 'Titanic']
print(f"\n=== CONTENT-BASED RECOMMENDATIONS ===")

for movie in sample_movies:
    print(f"\n--- Rekomendasi berdasarkan '{movie}' ---")
    recommendations = cb_recommender.get_recommendations(movie, 5)
    if isinstance(recommendations, pd.DataFrame):
        print(recommendations.to_string(index=False))
    else:
        print(recommendations)
    print("-" * 50)

"""## ===== 4. COLLABORATIVE FILTERING ====="""

class CollaborativeFilteringRecommender:
    def __init__(self, ratings_df, movies_df):
        self.ratings_df = ratings_df
        self.movies_df = movies_df
        self.model = None
        self.trainset = None
        self.testset = None

    def prepare_data(self):
        """Persiapan data untuk Surprise library"""
        reader = Reader(rating_scale=(1, 5))
        data = Dataset.load_from_df(self.ratings_df[['user_id', 'movie_id', 'rating']], reader)

        # Split data
        self.trainset, self.testset = surprise_split(data, test_size=0.2, random_state=42)

    def train_svd_model(self):
        """Training model SVD"""
        self.model = SVD(random_state=42)
        self.model.fit(self.trainset)

        # Evaluasi
        predictions = self.model.test(self.testset)
        rmse = accuracy.rmse(predictions, verbose=False)
        mae = accuracy.mae(predictions, verbose=False)

        print(f"SVD Model - RMSE: {rmse:.4f}, MAE: {mae:.4f}")
        return rmse, mae

    def train_knn_model(self):
        """Training model KNN"""
        self.knn_model = KNNBasic(sim_options={'user_based': True})
        self.knn_model.fit(self.trainset)

        # Evaluasi
        predictions = self.knn_model.test(self.testset)
        rmse = accuracy.rmse(predictions, verbose=False)
        mae = accuracy.mae(predictions, verbose=False)

        print(f"KNN Model - RMSE: {rmse:.4f}, MAE: {mae:.4f}")
        return rmse, mae

    def get_user_recommendations(self, user_id, n_recommendations=5):
        """Mendapatkan rekomendasi untuk user"""
        if self.model is None:
            print("Model belum di-training!")
            return None

        # Dapatkan film yang belum ditonton user
        user_movies = set(self.ratings_df[self.ratings_df['user_id'] == user_id]['movie_id'])
        all_movies = set(self.movies_df['movie_id'])
        unrated_movies = all_movies - user_movies

        # Prediksi rating untuk film yang belum ditonton
        predictions = []
        for movie_id in unrated_movies:
            pred = self.model.predict(user_id, movie_id)
            predictions.append((movie_id, pred.est))

        # Sort berdasarkan predicted rating
        predictions.sort(key=lambda x: x[1], reverse=True)

        # Ambil top N recommendations
        top_movies = predictions[:n_recommendations]

        # Gabungkan dengan informasi film
        recommendations = []
        for movie_id, predicted_rating in top_movies:
            movie_info = self.movies_df[self.movies_df['movie_id'] == movie_id]
            if not movie_info.empty:
                movie_info = movie_info.iloc[0]
                recommendations.append({
                    'title': movie_info['title'],
                    'genres': movie_info['genres'],
                    'year': movie_info['year'],
                    'predicted_rating': round(predicted_rating, 2)
                })

        return pd.DataFrame(recommendations)

# Implementasi Collaborative Filtering
print("\n=== COLLABORATIVE FILTERING ===")
cf_recommender = CollaborativeFilteringRecommender(ratings_df, movies_df)
cf_recommender.prepare_data()

# Training models
print("\nTraining SVD Model...")
svd_rmse, svd_mae = cf_recommender.train_svd_model()

print("\nTraining KNN Model...")
knn_rmse, knn_mae = cf_recommender.train_knn_model()

# Test rekomendasi untuk beberapa user
test_users = [1, 5, 10, 25, 50]
print(f"\n=== COLLABORATIVE FILTERING RECOMMENDATIONS ===")

for user in test_users:
    if user in ratings_df['user_id'].values:
        print(f"\n--- Rekomendasi untuk User {user} ---")

        # Tampilkan preferensi user (film yang sudah dirating tinggi)
        user_high_ratings = ratings_df[
            (ratings_df['user_id'] == user) &
            (ratings_df['rating'] >= 4.0)
        ].merge(movies_df, on='movie_id').sort_values('rating', ascending=False)

        if not user_high_ratings.empty:
            print(f"Film favorit user (rating ≥ 4.0):")
            print(user_high_ratings[['title', 'genres', 'rating']].head(3).to_string(index=False))

        # Dapatkan rekomendasi
        user_recommendations = cf_recommender.get_user_recommendations(user, 5)
        if isinstance(user_recommendations, pd.DataFrame) and not user_recommendations.empty:
            print(f"\nRekomendasi untuk User {user}:")
            print(user_recommendations.to_string(index=False))
        else:
            print(f"Tidak dapat memberikan rekomendasi untuk User {user}")
        print("-" * 80)

"""## ===== 5. HYBRID RECOMMENDER ====="""

class HybridRecommender:
    def __init__(self, cb_recommender, cf_recommender, weight_cb=0.3, weight_cf=0.7):
        self.cb_recommender = cb_recommender
        self.cf_recommender = cf_recommender
        self.weight_cb = weight_cb
        self.weight_cf = weight_cf

    def get_hybrid_recommendations(self, user_id, n_recommendations=5):
        """Mendapatkan rekomendasi hybrid"""
        # Dapatkan film yang paling disukai user
        user_ratings = ratings_df[ratings_df['user_id'] == user_id]
        if user_ratings.empty:
            return "User tidak ditemukan"

        # Ambil film dengan rating tertinggi dari user
        top_user_ratings = user_ratings.nlargest(3, 'rating')

        print(f"=== HYBRID RECOMMENDATIONS FOR USER {user_id} ===")
        print(f"Film-film yang disukai user:")
        for _, row in top_user_ratings.iterrows():
            movie_title = movies_df[movies_df['movie_id'] == row['movie_id']]['title'].iloc[0]
            print(f"- {movie_title} (Rating: {row['rating']})")

        # Ambil film dengan rating tertinggi untuk content-based
        top_rated_movie = top_user_ratings.iloc[0]
        movie_title = movies_df[movies_df['movie_id'] == top_rated_movie['movie_id']]['title'].iloc[0]

        # Content-based recommendations
        print(f"\n--- Content-Based Recommendations (based on '{movie_title}') ---")
        cb_recs = self.cb_recommender.get_recommendations(movie_title, n_recommendations)
        if isinstance(cb_recs, pd.DataFrame):
            print(cb_recs.to_string(index=False))
        else:
            print(cb_recs)

        # Collaborative filtering recommendations
        print(f"\n--- Collaborative Filtering Recommendations ---")
        cf_recs = self.cf_recommender.get_user_recommendations(user_id, n_recommendations)
        if isinstance(cf_recs, pd.DataFrame):
            print(cf_recs.to_string(index=False))
        else:
            print(cf_recs)

        return cb_recs, cf_recs

print("\n=== HYBRID RECOMMENDER SYSTEM ===")
hybrid_recommender = HybridRecommender(cb_recommender, cf_recommender)

# Test dengan beberapa user
test_users_hybrid = [1, 10, 25]
for user in test_users_hybrid:
    if user in ratings_df['user_id'].values:
        print(f"\n{'='*80}")
        cb_results, cf_results = hybrid_recommender.get_hybrid_recommendations(user)
        print(f"{'='*80}")
    else:
        print(f"User {user} tidak ditemukan dalam dataset")

"""## ===== 6. VISUALISASI DAN ANALISIS =====

### Distribusi Rating
"""

plt.figure(figsize=(8, 5))
ratings_df['rating'].hist(bins=10, alpha=0.7, color='skyblue', edgecolor='black')
plt.title('Distribusi Rating')
plt.xlabel('Rating')
plt.ylabel('Frequency')
plt.show()

"""### Top 10 Genre Distribution"""

plt.figure(figsize=(8, 5))
genre_counts = pd.Series(all_genres).value_counts().head(10)
plt.pie(genre_counts.values, labels=genre_counts.index, autopct='%1.1f%%', startangle=90)
plt.title('Top 10 Genre Distribution')
plt.show()

"""### Jumlah Rating per User"""

plt.figure(figsize=(8, 5))
user_rating_counts = ratings_df['user_id'].value_counts()
plt.hist(user_rating_counts, bins=30, alpha=0.7, color='lightgreen')
plt.title('Jumlah Rating per User')
plt.xlabel('Jumlah Rating')
plt.ylabel('Jumlah User')
plt.show()

"""### Jumlah Rating per Film"""

plt.figure(figsize=(8, 5))
movie_rating_counts = ratings_df['movie_id'].value_counts()
plt.hist(movie_rating_counts, bins=30, alpha=0.7, color='lightcoral')
plt.title('Jumlah Rating per Film')
plt.xlabel('Jumlah Rating')
plt.ylabel('Jumlah Film')
plt.show()

"""### Distribusi Rating Rata-rata Film"""

plt.figure(figsize=(8, 5))
avg_ratings = ratings_df.groupby('movie_id')['rating'].mean()
plt.hist(avg_ratings, bins=30, alpha=0.7, color='gold')
plt.title('Distribusi Rating Rata-rata Film')
plt.xlabel('Rating Rata-rata')
plt.ylabel('Jumlah Film')
plt.show()

"""### Perbandingan Performa Model"""

plt.figure(figsize=(8, 5))
models = ['SVD', 'KNN']
rmse_scores = [svd_rmse, knn_rmse]
mae_scores = [svd_mae, knn_mae]

x = np.arange(len(models))
width = 0.35

bars1 = plt.bar(x - width/2, rmse_scores, width, label='RMSE', alpha=0.8, color='navy')
bars2 = plt.bar(x + width/2, mae_scores, width, label='MAE', alpha=0.8, color='darkred')

plt.xlabel('Model')
plt.ylabel('Error')
plt.title('Perbandingan Performa Model')
plt.xticks(x, models)
plt.legend()

for bar in bars1:
    height = bar.get_height()
    plt.text(bar.get_x() + bar.get_width()/2., height + 0.01,
             f'{height:.3f}', ha='center', va='bottom')
for bar in bars2:
    height = bar.get_height()
    plt.text(bar.get_x() + bar.get_width()/2., height + 0.01,
             f'{height:.3f}', ha='center', va='bottom')
plt.show()

"""### Rating Activity Over Time"""

plt.figure(figsize=(10, 5))
ratings_df['timestamp'] = pd.to_datetime(ratings_df['timestamp'], unit='s')
ratings_by_month = ratings_df.groupby(ratings_df['timestamp'].dt.to_period('M')).size()
plt.plot(ratings_by_month.index.to_timestamp(), ratings_by_month.values)
plt.title('Rating Activity Over Time')
plt.xlabel('Time')
plt.ylabel('Number of Ratings')
plt.xticks(rotation=45)
plt.show()

"""### Top 10 Highest Rated Movies"""

plt.figure(figsize=(10, 6))
movie_stats = ratings_df.groupby('movie_id').agg({
    'rating': ['mean', 'count']
}).round(2)
movie_stats.columns = ['avg_rating', 'rating_count']
popular_movies = movie_stats[movie_stats['rating_count'] >= 50].sort_values('avg_rating', ascending=False)
top_movies = popular_movies.head(10)
top_movies_with_titles = top_movies.merge(movies_df[['movie_id', 'title']], left_index=True, right_on='movie_id')

plt.barh(range(len(top_movies_with_titles)), top_movies_with_titles['avg_rating'], alpha=0.7)
plt.yticks(range(len(top_movies_with_titles)),
           [title[:20] + '...' if len(title) > 20 else title for title in top_movies_with_titles['title']])
plt.xlabel('Average Rating')
plt.title('Top 10 Highest Rated Movies\n(min 50 ratings)')
plt.show()

"""### Distribution of User Average Ratings"""

plt.figure(figsize=(8, 5))
user_avg_ratings = ratings_df.groupby('user_id')['rating'].mean()
plt.hist(user_avg_ratings, bins=20, alpha=0.7, color='purple')
plt.title('Distribution of User Average Ratings')
plt.xlabel('Average Rating')
plt.ylabel('Number of Users')
plt.show()

"""### Movies by Release Year"""

plt.figure(figsize=(10, 5))
movies_df_clean = movies_df.dropna(subset=['year'])
year_counts = movies_df_clean['year'].value_counts().sort_index()
plt.plot(year_counts.index, year_counts.values, alpha=0.7)
plt.title('Movies by Release Year')
plt.xlabel('Year')
plt.ylabel('Number of Movies')
plt.show()

"""### Average Rating vs Number of Ratings"""

plt.figure(figsize=(8, 5))
movie_stats_corr = ratings_df.groupby('movie_id').agg({
    'rating': ['mean', 'count']
})
movie_stats_corr.columns = ['avg_rating', 'rating_count']
plt.scatter(movie_stats_corr['rating_count'], movie_stats_corr['avg_rating'], alpha=0.5)
plt.xlabel('Number of Ratings')
plt.ylabel('Average Rating')
plt.title('Average Rating vs Number of Ratings')
plt.show()

"""### Dataset Sparsity"""

plt.figure(figsize=(8, 5))
sparsity = 1 - (len(ratings_df) / (ratings_df['user_id'].nunique() * ratings_df['movie_id'].nunique()))
categories = ['Filled', 'Empty']
values = [1-sparsity, sparsity]
colors = ['lightblue', 'lightgray']
plt.pie(values, labels=categories, autopct='%1.1f%%', colors=colors)
plt.title(f'Dataset Sparsity\n({sparsity:.1%} empty)')
plt.show()

"""## ===== 7. EVALUASI DAN KESIMPULAN ====="""

print("\n=== EVALUASI SISTEM REKOMENDASI ===")
print("\n1. Content-Based Filtering:")
print("   - Menggunakan TF-IDF untuk feature extraction")
print("   - Cosine similarity untuk menghitung kemiripan")
print("   - Cocok untuk item baru (cold start problem)")
print("   - Rekomendasi berdasarkan kesamaan konten")

print("\n2. Collaborative Filtering:")
print(f"   - SVD Model: RMSE = {svd_rmse:.4f}, MAE = {svd_mae:.4f}")
print(f"   - KNN Model: RMSE = {knn_rmse:.4f}, MAE = {knn_mae:.4f}")
print("   - Menggunakan pola rating user untuk rekomendasi")
print("   - Dapat menemukan preferensi tersembunyi")

print("\n3. Hybrid Approach:")
print("   - Kombinasi kedua metode untuk hasil yang lebih baik")
print("   - Mengatasi kelemahan masing-masing metode")
print("   - Memberikan rekomendasi yang lebih diverse")

print("\n=== CARA PENGGUNAAN ===")
print("1. Untuk Content-Based: cb_recommender.get_recommendations('Film 1', 5)")
print("2. Untuk Collaborative: cf_recommender.get_user_recommendations(1, 5)")
print("3. Untuk Hybrid: hybrid_recommender.get_hybrid_recommendations(1)")